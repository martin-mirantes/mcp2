# Descripción del Proyecto: Backend FastMCP para Gestión de Tarefas

## 1. Introducción y Objetivo

Este documento describe el diseño y plan de implementación para un servidor backend basado en **FastMCP v2**, la librería Python para construir servidores y clientes del **Model Context Protocol (MCP)**. El objetivo principal de este servidor es actuar como una interfaz robusta y segura entre un agente de Inteligencia Artificial (IA) y una base de datos PostgreSQL, utilizando el protocolo MCP para la comunicación.

El sistema gestionará información relacionada con tarefas de construcción o mantenimiento (inicialmente enfocado en pintura), incluyendo la estructura jerárquica de las obras, la definición detallada y polimórfica de los locais de trabalho, la asignación de tarefas, la gestión de responsáveis (incluyendo equipos con distribución porcentual) y la asociación de preços a combinaciones específicas de tarefa y local.

La IA interactuará exclusivamente con el servidor FastMCP a través del protocolo MCP, utilizando los `Tools`, `Resources`, `Resource Templates` y `Prompts` expuestos por el servidor. El backend FastMCP abstraerá la complejidad de la base de datos y aplicará la lógica de negocio necesaria.

## 2. Requisitos Iniciales

Los requisitos funcionales se mantienen, pero ahora se enfocarán en cómo se exponen a través de MCP:

* **Gestión Jerárquica:** Exponer `Resources` o `Tools` para definir y consultar la estructura de Obras -> Módulos -> Blocos -> Pavimentos -> Apartamentos.
* **Gestión de Locais (Polimórfica):**
    * Definir `Resources` y `Tools` para gestionar la tabla base `locais` y las tablas específicas (`local_apartamento`, `local_ambiente_interno_apartamento`, etc.), reflejando la estructura polimórfica.
    * La creación de un `local` específico implicará la creación coordinada del registro base y el específico, manejado por un `Tool`.
    * La lectura podría usar `Resource Templates` (ej: `locais://id/{local_id}`) que devuelvan la información completa del local específico.
* **Gestión de Tipos de Tarefas:** Exponer `Tools` y `Resources` para CRUD de `tipos_tarefas`.
* **Gestión de Responsáveis:** Exponer `Tools` y `Resources` para CRUD de `responsaveis`.
* **Gestión de Tarefas:**
    * Exponer `Tools` para crear, leer, actualizar y eliminar `tarefas`.
    * Un `Tool` de creación de tarefa debe manejar la asociación con `local_id`, `tipos_tarefa_id`, y la asignación de múltiplos `responsaveis` (a través de la tabla `tarefa_responsaveis`).
    * La lógica de validación de la suma 100% y `eh_principal` para `tarefa_responsaveis` se implementará dentro del `Tool` correspondiente (o se confiará en el trigger de la DB).
* **Gestión de Precios:**
    * Definir precios estándar basados en la combinación de `tipos_tarefa` y `local`.
    * Asociar una tarefa a un registro de precio estándar aplicable en el momento de su creación/precificación.
* **Interacción con IA (MCP):** El servidor FastMCP expondrá sus capacidades directamente a través del protocolo MCP. La documentación de los `Tools`, `Resources`, etc. (generada a partir de docstrings y type hints) será la "API" para la IA.

## 3. Resumen del Esquema y Datos de la Base de Datos (PostgreSQL)

*Basado en el dump `archivo.sql` proporcionado.*

```text
# Resumen del Esquema y Datos Muestra de la Base de Datos PostgreSQL (Schema: public) para Referencia de LLM (Actualizado)

## ENUM Types

### public.tipo_local_enum
- Define los tipos válidos para la columna `tipo_local` en la tabla `locais`.
- Valores Posibles:
  - 'AMBIENTE_INTERNO_APARTAMENTO'
  - 'AREA_COMUM_INTERNA_BLOCO'
  - 'AREA_COMUM_FACHADA_BLOCO'
  - 'AREA_COMUM_EXTERNA_BLOCO'
  - 'AREA_COMUM_MODULO'
  - 'RUA'
  - 'APARTAMENTO'

## Estructura Jerárquica Principal y Datos Muestra

### public.obras
- Representa las obras o proyectos principales.
- **Columnas:**
  - `obra_id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único de la obra.
  - `nome` (TEXT, NOT NULL) - Nombre de la obra.
- **Datos:**
  - (1, 'ML1')
  - (2, 'ML2')

### public.modulos
- Representa los módulos dentro de una obra.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del módulo.
  - `nome` (TEXT, NOT NULL) - Nombre del módulo.
  - `obra_id` (BIGINT, FK -> obras.obra_id, NOT NULL) - ID de la obra a la que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `modulos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_obra_nome` (UNIQUE(obra_id, nome)) - Nombre del módulo debe ser único dentro de la obra.
- **Datos:**
  - (1, '01', 2)
  - (2, '02', 2)
  - (3, '03', 2)
  - (4, '04', 2)
  - (5, '05', 2)
  - (6, '06', 2)

### public.blocos
- Representa los bloques dentro de un módulo.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del bloco.
  - `nome` (TEXT, NOT NULL) - Nombre del bloco.
  - `modulo_id` (BIGINT, FK -> modulos.id, NOT NULL) - ID del módulo al que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `blocos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_modulo_nome` (UNIQUE(modulo_id, nome)) - Nombre del bloco debe ser único dentro del módulo.
- **Datos (Muestra):**
  - (1, '01', 6)
  - (2, '02', 6)
  - (...90 registros en total)
  - (70, '70', 4) -- Asumiendo Módulo 4 existe
  - (90, '90', 3)

### public.pavimentos
- Representa los pisos o pavimentos dentro de un bloco.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del pavimento.
  - `nome` (TEXT, NOT NULL) - Nombre/Número del pavimento (ej: 'Térreo', '01', '02').
  - `bloco_id` (BIGINT, FK -> blocos.id, NOT NULL) - ID del bloco al que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `pavimentos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_bloco_nome` (UNIQUE(bloco_id, nome)) - Nombre del pavimento debe ser único dentro del bloco.
- **Datos (Muestra):**
  - (1, '01', 1)
  - (2, '02', 1)
  - (...360 registros en total)
  - (360, '04', 90)

### public.apartamentos
- Representa los apartamentos o unidades dentro de un pavimento.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único del apartamento.
  - `nome` (TEXT, NOT NULL) - Nombre/Número del apartamento (ej: '101', '205B').
  - `pavimento_id` (BIGINT, FK -> pavimentos.id, NOT NULL) - ID del pavimento al que pertenece.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `apartamentos`, pero se asume por consistencia. Si no existe, ignorar).
- **Constraints:**
  - `unique_pavimento_nome` (UNIQUE(pavimento_id, nome)) - Nombre del apartamento debe ser único dentro del pavimento.
- **Datos (Muestra):**
  - (1, '101', 1)
  - (2, '102', 1)
  - (...1440 registros en total)
  - (1113, '301', 281) -- Apto 301, Bloco 70, Pav 03 (ID 281)
  - (1440, '404', 360)

## Estructura de Locais (Polimórfica) y Datos Muestra

### public.locais (Tabla Base)
- Tabla central para todas las ubicaciones. Contiene datos comunes.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL) - ID único para CUALQUIER tipo de local.
  - `tipo_local` (public.tipo_local_enum, NOT NULL) - **Discriminador**. Indica qué tabla específica contiene los detalles.
  - `nome_display` (VARCHAR(350), NOT NULL) - Nombre descriptivo completo para mostrar.
  - `obra_id` (BIGINT, FK -> obras.obra_id, NOT NULL, ON DELETE RESTRICT) - ID de la obra a la que pertenece el local.
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `locais`, pero se asume por consistencia. Si no existe, ignorar).
- **Datos:**
  - (17, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 101', 2)
  - (18, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 102', 2)
  - (19, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 103', 2)
  - (20, 'AMBIENTE_INTERNO_APARTAMENTO', 'ML2 - Módulo 04 - Bloco 70 - Pavimento 01 - Apto 104', 2)
  - (25, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 301', 2)
  - (26, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 302', 2)
  - (27, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 303', 2)
  - (28, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 304', 2)
  - (29, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 401', 2)
  - (30, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 402', 2)
  - (31, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 403', 2)
  - (32, 'APARTAMENTO', 'ML2 / M04 / B70 / Apt 404', 2)
  - (Nota: Los locales 21-24 del dump original tenían tipo APARTAMENTO pero no tenían entrada en local_apartamento. Se listan aquí como referencia, pero pueden requerir corrección en los datos reales).

### public.local_ambiente_interno_apartamento (Tipo Específico)
- Detalles para locales de tipo 'AMBIENTE_INTERNO_APARTAMENTO'.
- **Columnas:**
  - `local_id` (BIGINT, PK, FK -> locais.id, ON DELETE CASCADE)
  - `apartamento_id` (BIGINT, FK -> apartamentos.id, NOT NULL, ON DELETE CASCADE)
  - `nome_ambiente` (VARCHAR(150), NOT NULL)
- **Datos:**
  - (17, 1105, 'Apartamento Completo')
  - (18, 1106, 'Apartamento Completo')
  - (19, 1107, 'Apartamento Completo')
  - (20, 1108, 'Apartamento Completo')

### public.local_apartamento (Tipo Específico)
- Detalles para locales de tipo 'APARTAMENTO'.
- **Columnas:**
  - `local_id` (BIGINT, PK, FK -> locais.id, ON DELETE CASCADE)
  - `apartamento_id` (BIGINT, FK -> apartamentos.id, NOT NULL, ON DELETE CASCADE)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `local_apartamento`, pero se asume por consistencia. Si no existe, ignorar).
- **Datos:**
  - (25, 1113)
  - (26, 1114)
  - (27, 1115)
  - (28, 1116)
  - (29, 1117)
  - (30, 1118)
  - (31, 1119)
  - (32, 1120)

### (Otras tablas `local_...` específicas)
- `local_area_comum_interna_bloco`, `local_area_comum_fachada_bloco`, `local_area_comum_externa_bloco`, `local_area_comum_modulo`, `local_rua`.
- **Datos:** (Vacias según el dump)

## Otras Tablas Principales y Datos Muestra

### public.tipos_tarefas
- Define los diferentes tipos de tareas que se pueden realizar.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `nome` (VARCHAR(255), NOT NULL, UNIQUE)
  - `funcao` (TEXT, NULL)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now()) - (Nota: `created_at` no está en el dump de `tipos_tarefas`, pero se asume por consistencia. Si no existe, ignorar).
- **Datos:**
  - (1, 'Massa e 1º demão', 'PINTOR')
  - (2, '2ª Demão', 'PINTOR')

### public.responsaveis
- Almacena información sobre los trabajadores o responsables.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `nome` (TEXT, NOT NULL, UNIQUE)
  - `matricula` (NUMERIC, NULL)
  - `funcao` (TEXT, NULL)
  - `data_admissao` (DATE, NULL)
  - `situacao` (TEXT, NULL)
  - `salario_categoria` (NUMERIC, NULL)
  - `obra_id` (BIGINT, FK -> obras.obra_id, NULL)
- **Datos (Muestra):**
  - (61, 'ADEMIR ALVES FILHO', 741, 'PINTOR', '2025-04-14', 'Ativo', 1821.64, 2)
  - (62, 'ALBERI DANTAS DA SILVA', 193, 'GESSEIRO', '2022-05-02', 'Ativo', 1821.64, 2)
  - (...186 registros en total)
  - (246, 'WERBSON NUNES XAVIER', 161, 'MONT. ANDAIMES', '2021-11-17', 'Afastado', 1821.64, 2)

### public.precos_tarefa_local
- Almacena los precios estándar para una combinación de tipo de tarefa y local.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `tipos_tarefa_id` (BIGINT, FK -> tipos_tarefas.id, NOT NULL, ON DELETE CASCADE)
  - `local_id` (BIGINT, FK -> locais.id, NOT NULL, ON DELETE CASCADE)
  - `preco` (NUMERIC(12, 2), NOT NULL, CHECK preco >= 0)
  - `unidade_medida` (VARCHAR(50), NULL)
  - `validade_inicio` (DATE, NULL, DEFAULT CURRENT_DATE)
  - `validade_fim` (DATE, NULL)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now())
- **Constraints:**
  - `uq_preco_tipo_local_unidade` (UNIQUE(tipos_tarefa_id, local_id, unidade_medida))
- **Datos:** (Vacía según el dump)

### public.tarefas
- Tabla principal que registra las tareas a realizar.
- **Columnas:**
  - `id` (BIGINT, PK, GENERATED BY DEFAULT AS IDENTITY, NOT NULL)
  - `nome` (TEXT, NOT NULL)
  - `created_at` (TIMESTAMPTZ, NOT NULL, DEFAULT now())
  - `inicio` (DATE, NULL)
  - `fim` (DATE, NULL)
  - `local_id` (BIGINT, FK -> locais.id, NULL, ON DELETE SET NULL)
  - `tipos_tarefa_id` (BIGINT, FK -> tipos_tarefas.id, NULL, ON DELETE SET NULL)
  - `preco_tarefa_local_id` (BIGINT, FK -> precos_tarefa_local.id, NULL, ON DELETE SET NULL)
- **Datos:** (Vacía según el dump)

## Tablas de Relación (Many-to-Many) y Datos Muestra

### public.tarefa_responsaveis
- Tabla de junção que conecta tarefas com seus múltiplos responsáveis e armazena detalhes da atribuição.
- **Columnas:**
  - `tarefa_id` (BIGINT, PK part, FK -> tarefas.id, NOT NULL, ON DELETE CASCADE)
  - `responsavel_id` (BIGINT, PK part, FK -> responsaveis.id, NOT NULL, ON DELETE CASCADE)
  - `percentual` (NUMERIC(5, 2), NOT NULL, DEFAULT 100.00, CHECK > 0 AND <= 100.00)
  - `eh_principal` (BOOLEAN, NOT NULL, DEFAULT FALSE)
- **Constraints:**
  - `tarefa_responsaveis_pkey` (PRIMARY KEY(tarefa_id, responsavel_id))
- **Nota:** A validação da soma dos `percentual` para 100% por `tarefa_id` é feita por Trigger.
- **Datos:** (Vacía según el dump)

## Funciones y Triggers Notables

- `public.checar_soma_100_tarefa(BIGINT)`: Función que verifica si la suma de `percentual` en `tarefa_responsaveis` es 100 para una `tarefa_id` dada.
- `public.trigger_checar_soma_100_tarefa()`: Función de Trigger que llama a la función de verificación.
- `trig_checar_soma_100` en `tarefa_responsaveis`: CONSTRAINT TRIGGER que usa las funciones anteriores para forzar la suma de 100% no `COMMIT` da transação.
- `public.sum_function(integer, integer)`: Función de ejemplo (no parece estar directamente relacionada con el esquema principal de negocio).

## Resumen de Relaciones Clave para Consultas

- **Jerarquía:** `obras` -> `modulos` -> `blocos` -> `pavimentos` -> `apartamentos`.
- **Localización:**
  - `tarefas.local_id` -> `locais.id` (Obtiene información común del local y el `tipo_local`).
  - Dependiendo de `locais.tipo_local`, hacer JOIN con la tabla específica correspondiente (`local_ambiente_interno_apartamento`, `local_apartamento`, `local_rua`, etc.) usando `locais.id = tabla_especifica.local_id`.
  - Para obtener la jerarquía completa de un local, hacer JOIN desde `locais.obra_id` y/o desde las FKs nas tabelas específicas (`apartamento_id`, `bloco_id`, `modulo_id`).
- **Responsables:**
  - `tarefas` -> `tarefa_responsaveis` (JOIN en `tarefas.id = tarefa_responsaveis.tarefa_id`).
  - `tarefa_responsaveis` -> `responsaveis` (JOIN en `tarefa_responsaveis.responsavel_id = responsaveis.id`).
- **Tipo de Tarefa:** `tarefas.tipos_tarefa_id` -> `tipos_tarefas.id`.
- **Precio Estándar:** `tarefas.preco_tarefa_local_id` -> `precos_tarefa_local.id`. Para obtener los detalles del precio (tipo y local a los que se aplica), hacer JOIN adicional desde `precos_tarefa_local` para `tipos_tarefas` y `locais`.

```

## 4. Arquitectura Backend Sugerida (Adaptada para FastMCP)

* **Objetivo:** Exponer capacidades vía MCP, abstraer complejidad de DB, implementar lógica de negocio, garantizar integridad.
* **Tecnologías:**
    * Lenguaje: Python 3.x
    * **Framework MCP:** **FastMCP v2** (Núcleo del servidor)
    * ORM y Validación: SQLModel (Para interacción con DB y definición de datos)
    * Base de Datos: PostgreSQL
    * Migraciones: Alembic
    * Servidor: FastMCP puede correr vía Stdio, SSE, o HTTP (usando Uvicorn internamente para los modos de red).
* **Capas Lógicas (Adaptadas):**
    * **Capa de Interfaz MCP (FastMCP):**
        * Define la instancia principal `FastMCP`.
        * Registra `Tools` (`@mcp.tool`), `Resources` (`@mcp.resource`), `Resource Templates` (`@mcp.resource` con parámetros URI), y `Prompts` (`@mcp.prompt`).
        * Estas funciones decoradas **contienen la lógica de negocio**.
        * Utiliza modelos Pydantic/SQLModel para definir los parámetros y tipos de retorno de los `Tools`, `Resources`, etc., lo que genera el schema MCP.
        * Maneja la comunicación del protocolo MCP (Stdio, SSE, HTTP).
    * **Capa de Lógica de Negocio (Integrada en Funciones MCP):**
        * La lógica que antes estaba en "servicios" ahora reside directamente dentro de las funciones decoradas por FastMCP (`@mcp.tool`, `@mcp.resource`, etc.).
        * Estas funciones orquestan las operaciones, realizan validaciones de negocio (ej: suma 100% si no se usa trigger), y llaman a la capa de acceso a datos.
        * Pueden usar el objeto `Context` de FastMCP para logging, acceso a otros recursos, etc.
    * **Capa Acceso a Datos (SQLModel):**
        * Sin cambios significativos. Siguen siendo los modelos SQLModel que mapean a las tablas PostgreSQL.
        * La interacción con la DB se hace vía sesiones SQLAlchemy/SQLModel, inyectadas o creadas dentro de las funciones MCP.
    * **Base de Datos (PostgreSQL):**
        * Sin cambios. Almacena datos, ejecuta constraints y triggers.
* **Consideraciones:** Autenticación (FastMCP soporta OAuth 2.0 vía configuración), manejo de errores (FastMCP convierte excepciones Python en errores MCP), logging (vía `Context`), pruebas (FastMCP Client para pruebas in-memory), despliegue (depende del transporte elegido: script stdio, servidor HTTP/SSE), documentación MCP (generada a partir de docstrings/tipos).

## 5. Plan de Trabajo Sugerido (Adaptado para FastMCP)

* **Fase 1: Configuración Inicial y Fundación (Setup):** Estructura de proyecto, entorno virtual, dependencias (`fastmcp`, `sqlmodel`, `alembic`, `psycopg`), configuración (`.env`), conexión a DB (engine SQLModel), **instancia `FastMCP` básica**.
* **Fase 2: Generación de Modelos y Configuración de Migraciones:** (Sin cambios) Generar modelos SQLModel desde DB (con `sqlacodegen`), adaptar manualmente (herencia, relaciones, `Field`), inicializar y configurar Alembic, generar y estampar migración inicial (baseline).
* **Fase 3: Implementación de `Tools` y `Resources` para Entidades Simples:**
    * Implementar funciones Python decoradas con `@mcp.tool` y `@mcp.resource` para CRUD básico de `Obras`, `Modulos`, `Responsaveis`, `TiposTarefas`.
    * La lógica de DB (usando SQLModel) va *dentro* de estas funciones.
    * Usar type hints y docstrings claros para la documentación MCP.
* **Fase 4: Implementación del Polimorfismo (Locais) en MCP:**
    * Implementar un `@mcp.tool` para **crear** `Locais`: esta función recibirá datos discriminados (con `tipo_local`), resolverá IDs, creará el registro `Local` base y el específico, y guardará en DB.
    * Implementar un `@mcp.resource` (probablemente un **Resource Template** como `locais://id/{local_id}`) para **leer** un `Local`: la función usará SQLModel/SQLAlchemy para cargar el objeto polimórfico correcto y lo devolverá (FastMCP lo serializará).
* **Fase 5: Implementación Many-to-Many (Tarefas y Responsaveis) en MCP:**
    * Implementar `@mcp.tool` para crear/actualizar `Tarefas`. Este tool aceptará la información de la tarefa y una lista de responsáveis con sus porcentajes.
    * La lógica *dentro* del tool validará la suma 100% (si no se usa trigger) y `eh_principal`, y creará/actualizará los registros en `tarefas` y `tarefa_responsaveis`.
    * Implementar `@mcp.resource` o `Tool` para leer tarefas, incluyendo la información de sus responsáveis asociados (cargando la relación).
* **Fase 6: Implementación de Lógica de Precios en MCP:**
    * Implementar `@mcp.tool` y `@mcp.resource` para CRUD de `PrecosTarefaLocal`.
    * Modificar el `Tool` de creación/actualización de `Tarefas` para buscar y asignar el `preco_tarefa_local_id` correspondiente.
* **Fase 7: Lógica de Negocio Adicional y `Prompts`:**
    * Implementar cualquier otra lógica o `Tool` específico.
    * Definir `@mcp.prompt` para plantillas de interacción reutilizables si es necesario.
* **Fase 8: Autenticación (FastMCP):** Configurar la autenticación OAuth 2.0 en la instancia `FastMCP` si se requiere seguridad.
* **Fase 9: Pruebas (con FastMCP Client):**
    * Escribir pruebas usando `fastmcp.Client` para interactuar con la instancia `FastMCP` **en memoria**, probando los `Tools` y `Resources`.
* **Fase 10: Documentación y Despliegue:**
    * La documentación principal para la IA son los schemas y descripciones generadas por FastMCP a partir del código.
    * Configurar logging.
    * Decidir el **transporte** para producción (`stdio`, `streamable-http`, `sse`) y configurar el comando `mcp.run()` o el despliegue del servidor web correspondiente.

Este documento proporciona una visión general completa del proyecto, desde los requisitos hasta un plan de implementación detallado, sirviendo como una guía central para el desarrollo del backend MCP.

